# ReadWillBe Notification System Implementation Plan

This plan implements a dual notification system:
- Browser Push Notifications: Alerts users even when the app is closed (requires JavaScript)
- In-App Notifications: HTMX-powered notifications displayed within the app UI

The notification payload will be simple: a message indicating the user has readings due today.

================================================================================
PART 1: BROWSER PUSH NOTIFICATIONS
================================================================================

## 1.1 Configuration Updates

1. Add VAPID key environment variables to types/config.go:
   - VAPIDPublicKey string
   - VAPIDPrivateKey string
   - Hostname string (for notification icon URLs)

2. Update ConfigFromViper() to read new config values:
   - READWILLBE_VAPID_PUBLIC_KEY
   - READWILLBE_VAPID_PRIVATE_KEY
   - READWILLBE_HOSTNAME

3. Generate VAPID keys for development (one-time setup):
   - Use: go run github.com/SherClockHolmes/webpush-go/cmd/vapid-keygen@latest
   - Store in .env or docker-compose.yml for local dev

## 1.2 Database Model

4. Create types/push_subscription.go with PushSubscription struct:
   ```go
   type PushSubscription struct {
       gorm.Model
       UserID   uint   `gorm:"index"`
       Endpoint string `gorm:"uniqueIndex"`
       P256DH   string
       Auth     string
   }
   ```

5. Add relationship to User model in types/user.go:
   - Add: PushSubscriptions []PushSubscription

6. Run database migration (auto-migrates on startup via GORM)

## 1.3 Service Worker

7. Create static/serviceWorker.js:
   - Handle 'install' event (skip waiting)
   - Handle 'activate' event (claim clients)
   - Handle 'push' event:
     - Parse JSON payload: { title, body, icon, badge, data: { url } }
     - Call self.registration.showNotification()
   - Handle 'notificationclick' event:
     - Navigate to data.url or default to '/'
     - Focus existing window if open, otherwise open new

8. Create static icon assets:
   - static/icon-192.png (notification icon)
   - static/badge-128.png (notification badge for mobile)

## 1.4 Push Subscription Endpoints

9. Create cmd/readwillbe/push.go with handlers:

   a. saveSubscription(db *gorm.DB) echo.HandlerFunc
      - POST /push/subscribe
      - Parse JSON body: { endpoint, keys: { p256dh, auth } }
      - Get user from session
      - Upsert PushSubscription (update if endpoint exists)
      - Return 200 OK

   b. removeSubscription(db *gorm.DB) echo.HandlerFunc
      - POST /push/unsubscribe
      - Parse JSON body: { endpoint }
      - Delete matching subscription for current user
      - Return 200 OK

   c. removeAllSubscriptions(db *gorm.DB) echo.HandlerFunc
      - POST /push/unsubscribe-all
      - Get user from session
      - Delete all subscriptions for user
      - Return 200 OK

10. Register routes in cmd/readwillbe/server.go:
    - POST /push/subscribe
    - POST /push/unsubscribe
    - POST /push/unsubscribe-all

## 1.5 Background Notification Worker

11. Create notification worker in cmd/readwillbe/push.go:

    a. startNotificationWorker(cfg types.Config, db *gorm.DB)
       - Start goroutine with time.NewTicker(1 * time.Minute)
       - On each tick:
         - Get current time
         - Query users where:
           - NotificationsEnabled = true
           - NotificationTime matches current hour:minute
           - User has readings due today (join with readings table)
         - For each matching user, call sendNotification()

    b. sendNotification(cfg types.Config, db *gorm.DB, user types.User)
       - Get all PushSubscriptions for user
       - Build payload:
         ```json
         {
           "title": "ReadWillBe",
           "body": "You have readings due today!",
           "icon": "https://{hostname}/static/icon-192.png",
           "badge": "https://{hostname}/static/badge-128.png",
           "data": { "url": "/" }
         }
         ```
       - For each subscription:
         - Send via webpush.SendNotification()
         - If 410 Gone response, delete subscription from DB
         - Log errors but continue to other subscriptions

12. Call startNotificationWorker() in cmd/readwillbe/main.go after DB init

## 1.6 Account Page Updates for Push Subscriptions

13. Update views/account.templ to add browser subscription section:
    - Add card below notification settings
    - Show subscription status (subscribed/not subscribed)
    - "Enable Browser Notifications" button (if not subscribed)
    - "Disable Browser Notifications" button (if subscribed)
    - Include VAPID public key as data attribute for JS

14. Create static/push-setup.js (minimal JS for Web Push API):
    - Function to register service worker
    - Function to subscribe to push (uses VAPID key from data attribute)
    - Function to unsubscribe
    - POST to /push/subscribe or /push/unsubscribe
    - Trigger HTMX refresh of subscription status after success

15. Update views/layout.templ:
    - Include push-setup.js script
    - Register service worker on page load

## 1.7 Add webpush-go Dependency

16. Add dependency:
    - go get github.com/SherClockHolmes/webpush-go

================================================================================
PART 2: IN-APP NOTIFICATIONS (HTMX)
================================================================================

## 2.1 Notification Indicator Component

17. Create notification bell component in views/layout.templ:
    - Bell icon in navbar (next to user menu)
    - Badge showing count of unread notifications
    - Uses hx-get to poll for notification count
    - hx-trigger="every 60s" for periodic refresh

## 2.2 Notification Dropdown

18. Create views/notifications.templ:

    a. NotificationBell(count int) templ component
       - Bell icon with badge (if count > 0)
       - Dropdown menu on click
       - hx-get="/notifications/dropdown" hx-trigger="click"

    b. NotificationDropdown(readings []types.Reading) templ component
       - List of due readings (max 5)
       - "You have X readings due today" summary
       - Link to dashboard
       - Empty state if no readings

## 2.3 Notification Endpoints

19. Create cmd/readwillbe/notifications.go:

    a. notificationCount(db *gorm.DB) echo.HandlerFunc
       - GET /notifications/count
       - Get user from session
       - Count readings due today (not completed)
       - Return NotificationBell component with count

    b. notificationDropdown(db *gorm.DB) echo.HandlerFunc
       - GET /notifications/dropdown
       - Get user from session
       - Get readings due today (limit 5)
       - Return NotificationDropdown component

20. Register routes in cmd/readwillbe/server.go:
    - GET /notifications/count
    - GET /notifications/dropdown

## 2.4 Layout Integration

21. Update views/layout.templ navbar:
    - Add notification bell between nav links and user menu
    - Initial load includes hx-get="/notifications/count" hx-trigger="load"
    - Bell triggers dropdown on click

================================================================================
PART 3: TESTING
================================================================================

## 3.1 Unit Tests

22. Create cmd/readwillbe/push_test.go:
    - Test saveSubscription handler
    - Test removeSubscription handler
    - Test notification payload building

23. Create cmd/readwillbe/notifications_test.go:
    - Test notificationCount returns correct count
    - Test notificationDropdown returns correct readings

## 3.2 Integration Testing

24. Manual testing checklist:
    - [ ] Subscribe to push notifications from account page
    - [ ] Verify subscription saved in database
    - [ ] Wait for notification time, verify push received
    - [ ] Unsubscribe and verify removed from database
    - [ ] Verify in-app bell shows correct count
    - [ ] Verify dropdown shows due readings
    - [ ] Test notification click navigates to app

================================================================================
PART 4: ENVIRONMENT SETUP
================================================================================

## 4.1 Development Environment

25. Update docker-compose.yml with new env vars:
    ```yaml
    environment:
      - READWILLBE_VAPID_PUBLIC_KEY=...
      - READWILLBE_VAPID_PRIVATE_KEY=...
      - READWILLBE_HOSTNAME=localhost:8080
    ```

26. Update .env.example (if exists) with new variables

## 4.2 Documentation

27. Update README or CLAUDE.md with:
    - Instructions for generating VAPID keys
    - Required environment variables for push notifications
    - Note about HTTPS requirement for production push notifications

================================================================================
IMPLEMENTATION ORDER
================================================================================

Recommended order to minimize dependencies:

Phase A - Foundation:
  Steps 1-3   (Config)
  Steps 4-6   (Database model)
  Step 16     (Add webpush dependency)

Phase B - In-App Notifications (HTMX only, no JS):
  Steps 17-21 (Notification bell and dropdown)
  Step 23     (Tests)

Phase C - Browser Push Infrastructure:
  Steps 7-8   (Service worker and icons)
  Steps 9-10  (Subscription endpoints)
  Step 22     (Tests)

Phase D - Background Worker:
  Steps 11-12 (Notification worker)

Phase E - UI Integration:
  Steps 13-15 (Account page push management)
  Steps 25-27 (Environment and docs)

Phase F - Testing:
  Step 24     (Manual integration testing)

================================================================================
NOTES
================================================================================

- Browser push notifications require HTTPS in production (localhost works for dev)
- Service worker scope should be '/' to handle all pages
- VAPID keys are generated once and reused (don't regenerate in production)
- In-app notifications use polling (every 60s) - can switch to SSE later if needed
- Notification time comparison should account for timezone (store user timezone in future)
- Dead subscriptions (410 responses) should be cleaned up automatically
